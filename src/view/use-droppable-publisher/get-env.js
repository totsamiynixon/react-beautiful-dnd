// @flow
import getClosestScrollable from './get-closest-scrollable';

export type EnvScrollalbe = {|
  scrollableId: ScrollableId,
  element: Element,
|};

export type Env = {|
  scrollables: EnvScrollalbe[],
  isFixedOnPage: boolean,
|};

const getXPath = (el: ?Element): string => {
  if (!el || el.nodeType !== 1) {
    return '';
  }
  if (el.id) {
    return `//*[@id="${el.id}"']`;
  }
  const sames = [].filter.call(el.parentNode?.children ?? [], (x: Element) => {
    return x.tagName === el.tagName;
  });
  const index = sames.length > 1 ? `${[].indexOf.call(sames, el) + 1}]` : '';
  return `${getXPath(el.parentNode)}/${el.tagName.toLowerCase()}${index}`;
};

// TODO: do this check at the same time as the closest scrollable
// in order to avoid double calling getComputedStyle
// Do this when we move to multiple scroll containers
const getIsFixed = (el: ?Element): boolean => {
  if (!el) {
    return false;
  }
  const style: CSSStyleDeclaration = window.getComputedStyle(el);
  if (style.position === 'fixed') {
    return true;
  }
  return getIsFixed(el.parentElement);
};

export default (start: Element): Env => {
  const closestCrollables = (
    element: Element,
    initialArray: EnvScrollable[] = [],
  ): EnvScrollable[] => {
    const closestScrollable: ?Element = getClosestScrollable(element);
    if (!closestScrollable) {
      return initialArray;
    }

    initialArray.push({
      // xpath is more representable then autogenerated id
      scrollableId: getXPath(closestScrollable),
      element: closestScrollable,
    });

    if (closestScrollable && closestScrollable.parentElement) {
      closestCrollables(closestScrollable.parentElement, initialArray);
    }

    return initialArray;
  };

  const scrollables = closestCrollables(start);
  const isFixedOnPage: boolean = getIsFixed(start);

  return {
    scrollables,
    isFixedOnPage,
  };
};
